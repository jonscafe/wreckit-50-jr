import base64
from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad
from collections import deque

# Maze definition (replace '#' with walls and '.' with path)
maze = [
    "##################################################",
    "#...#.........#...#.....#...#.....#.....#.........",
    "###.#.#####.###.#.#.#.###.#.#.#.#.#####.#.#######.",
    "#...#...#...#...#.#.#.#...#...#.#.......#.#...#...",
    "#.#######.###.###.#.#.#.#######.#######.#.#.#.#.#.",
    "#.......#.......#...#...#.....#...#...#.#.#.#.#.#.",
    "#######.#############.#######.###.#.#.###.#.#.#.##",
    "#...#...#.....#.....#.........#...#.#.......#.#...",
    "#.###.###.###.#.###.#########.#.###.#############.",
    "#.....#...#...#.#.#.#.....#...#...#.#.....#.....#.",
    "#.#######.#.###.#.#.#.###.#.#####.#.#.#####.###.#.",
    "#...#.....#.....#...#.#...#...#.#...#.#...#...#.#.",
    "###.###.#########.###.#######.#.#####.#.#.###.#.#.",
    "#.#...#...#...#.#.#.#.........#.......#.#...#.#...",
    "#.###.#.#.#.#.#.#.#.#.#########.#####.#.###.#.####",
    "#.#...#.#...#.#...#.#.#.....#...#.....#...#.#.....",
    "#.#.###.#####.###.#.#.#.###.#####.###.###.#.#####.",
    "#...#.#.#...#...#.#...#.#.........#.....#.#.......",
    "#.###.#.#.#.#.#.#.###.#.###.#########.###.#.#####.",
    "#...#.#.#.#.#.#.#...#.#...#.#.......#.#...#.#...#.",
    "###.#.#.#.#.###.###.#.###.#.#.#####.#.#.#####.#.##",
    "#...#.#.#.#.....#...#.....#.#...#...#.#.......#...",
    "#.###.#.#.#######.#######.#####.#.###.###########.",
    "#...#...#...#.....#...#...#.....#...#.#.......#...",
    "###.#.#####.#.#####.#.#####.#######.###.#####.#.##",
    "#.#.#.#.....#...#...#.#...#...#.......#...#...#...",
    "#.#.###.#######.#.###.#.#.###.#.#####.###.#.#####.",
    "#.#.#...#.......#.#...#.#.#...#.#...#.....#.......",
    "#.#.#.###.#######.#.###.#.#.###.#.#.#############.",
    "#.#.#.#...........#.#...#...#...#.#.#...........#.",
    "#.#.#.#############.###.#########.#.#########.###.",
    "#...#.............#...#...#.......#.#.......#.....",
    "#.###############.###.###.#.#######.#.#####.###.##",
    "#.#.....#.....#...#.#...#.........#.#.#...#...#...",
    "#.#.###.#.###.#.###.###.#######.###.#.###.###.####",
    "#...#...#.#.#...#.....#...#.#...#...#.......#.#...",
    "#####.###.#.#########.###.#.#.###.#########.#.#.#.",
    "#...#.....#.......#...#...#.#...#.........#.#...#.",
    "#.#########.#####.#.#.#.###.###.#####.#####.#####.",
    "#.............#.#...#.#.#.#...#.#...#.......#...#.",
    "#####.#######.#.#.#####.#.#.#.#.#.#.#########.#.#.",
    "#...#.#.....#.#.#.#.....#...#.....#...#...#.#.#...",
    "#.#.###.###.#.#.#.#.###########.#####.#.#.#.#.###.",
    "#.#.....#.....#...#.#.........#.#...#...#...#.#...",
    "#.###.#####.#######.#.###.###.###.#.#####.###.#.##",
    "#.#...#...#.#.......#.#...#.#.#...#...#...#...#.#.",
    "#.#.###.#.###.#########.###.#.#.#####.#.###.###.#.",
    "#.#.#...#...#.#.........#.#...#.#.#...#.#...#...#.",
    "#.###.#####.#.#####.#####.#.###.#.#.#####.###.##..",
    "#.........#.........#...........#.........#......."
]

def genKey(path):
    key = bytearray(16)
    for i, (x, y) in enumerate(path):
        key[i % len(key)] ^= (x + y) % 256
    return bytes(key)

def getFlag(key, iv, ct):
    cipher = AES.new(key, AES.MODE_CBC, iv)
    decrypted = unpad(cipher.decrypt(ct), AES.block_size)
    return decrypted.decode('utf-8')

iv = base64.b64decode("mJKl/x5xJ1viL34VEVDI7g==")
ct = base64.b64decode("TbZavV/mHbnC4MYf5R0A46dC7wwE9LG/emivOaehXZhlr5Xd9HqVCIQuHscCV7j4")

def bfs_solve_maze(maze, start, end):
    queue = deque([([start], start)])
    visited = set()
    visited.add(start)

    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # Right, Down, Left, Up

    while queue:
        path, current = queue.popleft()
        if current == end:
            return path

        for direction in directions:
            next_position = (current[0] + direction[0], current[1] + direction[1])
            if (
                0 <= next_position[0] < len(maze)
                and 0 <= next_position[1] < len(maze[0])
                and maze[next_position[0]][next_position[1]] == '.'
                and next_position not in visited
            ):
                visited.add(next_position)
                queue.append((path + [next_position], next_position))

    return None

def solve_maze():
    start = (1, 1)
    end = (len(maze) - 2, len(maze[0]) - 2)

    print("Solving the maze using BFS...")
    path = bfs_solve_maze(maze, start, end)

    if path:
        user_key = genKey(path)
        hex_key = user_key.hex()
        print(f"Hex key: {hex_key}")

        flag = getFlag(user_key, iv, ct)
        print(f"Correct path found! Decrypted flag: {flag}")
    else:
        print("No path found!")

# Run the solution
solve_maze()
